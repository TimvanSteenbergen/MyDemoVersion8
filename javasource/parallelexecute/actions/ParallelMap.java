// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package parallelexecute.actions;

import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import com.mendix.core.Core;
import com.mendix.core.CoreException;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IDataType;
import com.mendix.systemwideinterfaces.core.IDataType.DataTypeEnum;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.webui.CustomJavaAction;
import parallelexecute.proxies.ENUM_ParallelActionsExceptionHandling;
import parallelexecute.proxies.ParallelExecuteOptions;

/**
 * Returns a list of object that are the result of executing the microflow with a corresponding object from the input list.
 * The called microflow should return object of type OutputType or a specialization of it.
 */
public class ParallelMap extends CustomJavaAction<java.util.List<IMendixObject>>
{
	private java.util.List<IMendixObject> List_;
	private java.lang.String Microflow_;
	private java.lang.String ReturnType_;

	public ParallelMap(IContext context, java.util.List<IMendixObject> List_, java.lang.String Microflow_, java.lang.String ReturnType_)
	{
		super(context);
		this.List_ = List_;
		this.Microflow_ = Microflow_;
		this.ReturnType_ = ReturnType_;
	}

	@java.lang.Override
	public java.util.List<IMendixObject> executeAction() throws Exception
	{
		// BEGIN USER CODE
		ParallelMap.validateParameterAndMicroflow(List_, Microflow_, ReturnType_, false);
		final ParallelMicroflowExecutor<List<IMendixObject>> executor =
				new ParallelMicroflowExecutor<>(getContext(), Microflow_, null, null);
		return executor.execute(() -> {
			return List_.parallelStream()
			.map((obj) -> {
				return (IMendixObject) executor.executeMicroflowInClonedContext(obj);
			})
			.collect(Collectors.toList());
		});
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "ParallelMap";
	}

	// BEGIN EXTRA CODE
	public static final long DEFAULT_TIMEOUT = parallelexecute.proxies.constants.Constants.getDEFAULT_TIMEOUT_MS();
	public static final long DEFAULT_NR_PARALLEL_THREADS = parallelexecute.proxies.constants.Constants.getDEFAULT_NUMBER_PARALLEL_THREADS();
	public static void  validateParameterAndMicroflow(List<IMendixObject> parameters, String microflowName, String outputType, boolean outputIsList) throws CoreException {
		Map<String, IDataType> args = Core.getInputParameters(microflowName);
		if ( args.size() != 1 )
			throw new CoreException("Wrong number of parameters: Microflow has either zero or two or more parameters while only zero or one are supported!");
		if ( parameters != null && ! parameters.isEmpty() ) {
			IMendixObject parameter = parameters.get(0);
			IDataType dataType = args.values().iterator().next();
			if ( dataType.getType() != DataTypeEnum.Object )
				throw new CoreException("Wrong parameter type: Microflow expects a parameter of type "+dataType.getType()+" but only type 'Object' is supported");
			if ( dataType.isList() )
				throw new CoreException("Wrong parameter cardinality: Microflow expects a List but only Object is supported");
			HashSet<String> generalizations = new HashSet<>();
			generalizations.addAll(Core.getMetaObject(parameter.getType()).getSuperObjects().stream().map(superType -> superType.getName()).collect(Collectors.toList()));
			generalizations.add(parameter.getType());
			if ( ! generalizations.contains(dataType.getObjectType()) )
				throw new CoreException("Wrong parameter entity: Microflow expects a parameter from entity '"+dataType.getObjectType()+"' but the provided object has entity '"+parameter.getType()+"'");
		}
		if ( outputType != null ) {
			IDataType returnType = Core.getReturnType(microflowName);
			if ( "Boolean".equals(outputType) ) {
				if ( returnType.getType() != DataTypeEnum.Boolean )
					throw new CoreException("Wrong return type: Microflow should return Boolean, but returns "+returnType.getType());
			} else {
				if ( outputIsList && returnType.getType() != DataTypeEnum.Object )
					throw new CoreException("Wrong return type: Microflow should return a List of entity '"+outputType+"', but returns "+returnType.getType());
				if ( ! outputIsList && returnType.getType() != DataTypeEnum.Object )
					throw new CoreException("Wrong return type: Microflow should return an Object of entity '"+outputType+"', but returns "+returnType.getType());
				if ( outputIsList && ! returnType.isList() )
					throw new CoreException("Wrong return cardinality: Microflow should return a List of entity '"+outputType+"', but returns "+returnType.getType());
				if ( ! outputIsList && returnType.isList() )
					throw new CoreException("Wrong return cardinality: Microflow should return an Object of entity '"+outputType+"', but returns "+returnType.getType());
				HashSet<String> generalizations = new HashSet<>();
				generalizations.addAll(Core.getMetaObject(returnType.getObjectType()).getSuperObjects().stream().map(superType -> superType.getName()).collect(Collectors.toList()));
				generalizations.add(returnType.getObjectType());
				if ( ! generalizations.contains(outputType) )
					throw new CoreException("Wrong return entity: Microflow should return object of entity '"+outputType+"', but returns '"+returnType.getObjectType()+"'");
			}
		}
	}
	
	public static class ParallelMicroflowExecutor <T> {
		T defaultValue;
		IContext context;
		String microflowName;
		List<Throwable> throwables = new LinkedList<>();
		long nrConcurentThreads;
		long timeoutMilliseconds;
		ENUM_ParallelActionsExceptionHandling exceptionHandling;
		
		public ParallelMicroflowExecutor(IContext context,
				String microflowName, T defaultValue,
				ParallelExecuteOptions options) {
			super();
			if ( options == null )
				options = new ParallelExecuteOptions(context);
			this.timeoutMilliseconds = options.getTimeout(context);
			this.nrConcurentThreads = options.getNrParallelThreads(context);
			this.exceptionHandling = options.getExceptionHandling(context);
			this.context = context;
			this.microflowName = microflowName;
			this.defaultValue = defaultValue;
		}
		
		public T execute(Callable<T> callable) throws Exception {
			ForkJoinPool forkJoinPool = null;
		    try {
		    	forkJoinPool = new ForkJoinPool((int) nrConcurentThreads);
				T res = (T) forkJoinPool.submit(callable).get(timeoutMilliseconds, TimeUnit.MILLISECONDS);
				if ( getExceptions() != null &&
					exceptionHandling != ENUM_ParallelActionsExceptionHandling.IgnoreException ) {
					Thread.sleep(100);
					throw getExceptions();
				}
				return res;
		    }
		    catch ( Exception e ) {
		    	if ( e.getCause() instanceof CoreException )
		    		throw (CoreException) e.getCause();
		    	if ( e.getCause() instanceof InterruptedException )
		    		throw (InterruptedException) e.getCause();
		    	if ( e.getCause() instanceof ExecutionException )
		    		throw (ExecutionException) e.getCause();
		    	throw e;
			} finally {
			    if (forkJoinPool != null) {
			        forkJoinPool.shutdownNow();
			    }
			}
		}

		public Object executeMicroflowInClonedContext(Object obj) {
			try {
				return Core.executeAsync(context.createClone(), microflowName, obj).get();
			} catch ( Throwable t ) {
				if ( exceptionHandling != ENUM_ParallelActionsExceptionHandling.StopAndThrowExceptionImmedietly  ) {
					throwables.add(t);
					return defaultValue;
				}
				else { 
					throw new RuntimeException(t);
				}
			}
		}
		
		private Exception getExceptions() {
			if ( throwables.isEmpty() ) return null;
			else return new Exception(throwables.stream()
					.map(t -> {
						StringBuilder sb = new StringBuilder();
						Throwable rootCause = t;
					    for (int i = 0 ; i < 10 && rootCause.getCause() != null && rootCause.getCause() != rootCause ; ++i ) {
					    	sb.append(rootCause.getMessage());
					        rootCause = rootCause.getCause();
					    }
					    return sb.toString();
					})
					.collect(Collectors.joining(", ")));
		}
	}
	// END EXTRA CODE
}
